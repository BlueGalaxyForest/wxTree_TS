
# 项目需求
## 概览
* 在一些OA系统,常常会使用到树形结构,树形结构大多数是PC端的,因此打算做个移动端的


# 项目准备:
## 大纲
* 创建项目->微信小程序TS版+sass的模板
* 删除无用文件跑个hello World =
	* 注意有个    // @ts-ignore 的东西啊 
	=> 在微信小程序中，如果你使用 TypeScript 进行开发，并且遇到某些情况下 TypeScript
		类型系统无法正确推断类型或者你明确知道某一处代码不符合类型规范，可以使用 // @ts-ignore 注释来忽略 TypeScript 的类型检查，让编译器跳过该部分代码的类型检查。
		
	* 
	
	
	
# 引入treeUtil,并且能够将任意指针关系的对象数组转化为 tree (ok)
## 大纲
* 在tree下面创建class (ok)
* 准备指针树列表(ok)
* 设计array的接口:  => 感觉就是: let arr:string[object] = [{a:1,b:2},{c:1}]
	const movieList = [
	  {
		movieId: 1,
		typeName: '中国分区',
		parentId: 1,
		date:'2023-11-23',
		area:'亚洲'
	  },
	  {
		movieId: 2,
		typeName: '日本分区',
		parentId: 1,
		date:'2023-11-25',
		area:'亚洲'
	  }]
	  
	const cityList = [
	  {
		cityId: 1,
		cityTitle: '深圳',
		fatherID: 1,
		province:'广东',
	  },
	  {
		cityId: 2,
		cityTitle: '广州',
		fatherID: 1,
		province:'广东'
	  }]  
	  
	  
* 类型“object”不能作为索引类型使用的 TS错误:
* 初步的转化树:
	/*
	  convertToTree(array: Array<{ [key: string]: any }>, name: string, id: string | number, fatherId: string | number) {

			const result: Array<{ [key: string]: any }> = [];
			const map: { [key: string]: any } = {};


			array.forEach((item) => {
			  item.title = item[name]
			  map[item[id]] = {
				...item
			  };
			});

			array.forEach((item) => {
			  const parent = map[item[fatherId]];
			  if (parent) {
				(parent.children || (parent.children = [])).push(map[item[id]]);
			  } else {

				result.push(map[item[id]]);
			  }
			});

			return result;
		  }
		}
	*/
	
* 需要利用接口改进:
	/*
	interface TreeNode { => 在 TypeScript 中，接口是类型的一种抽象描述，而不会生成具体的 JavaScript 代码。因此，接口的定义本身不需要导出，它在同一个项目内的任何文件中都是可见的，无需显式导入。
	  [key: string]: any;
	  title: string; // 假设 title 属性是每个节点都有的
	  children?: TreeNode[]; // 子节点数组，可选的
	}

	function convertToTree(array: Array<TreeNode>, name: string, id: string | number, fatherId: string | number): TreeNode[] {
	  const result: TreeNode[] = [];
	  const map: { [key: string]: TreeNode } = {};

	  array.forEach((item) => {
		item.title = item[name];
		map[item[id].toString()] = { // 将键转换为字符串，确保类型一致性
		  ...item,
		  children: [] // 初始化 children 数组
		};
	  });

	  array.forEach((item) => {
		const parent = map[item[fatherId]?.toString()]; // 使用可选链操作符确保不会出现 undefined
		if (parent) {
		  parent.children!.push(map[item[id].toString()]);
		} else {
		  result.push(map[item[id].toString()]);
		}
	  });

	  return result;
	}

	
	*/
	
* 先看看这颗树的转化效果如何=> 可以转化树
	
	
*  convertToTree()代码的可行性,时间复杂度和空间复杂度分析:  =>O(n) + O(n)
=> 最优化版本:
	/*
	  convertToTree(array: Array<any>, name: string, id: string | number, fatherId: string | number) {

		const result: Array<{ [key: string]: any }> = [];
		const map: { [key: string]: any } = {};

		array.forEach((item) => {
		  item.title = item[name]; // 把节点的中文值做一个统一处理
		  item.id = item[id]; // 把节点的id做一个统一处理

		  map[item[id]] = {
			...item
		  };

		  const parent = map[item[fatherId]];
		  if (parent) {
			(parent.children || (parent.children = [])).push(map[item[id]]);
		  } else {
			result.push(map[item[id]]);
		  }
		});

		return result;
	  }
	}

*/


# 根据转化的树做渲染(ok )
## 大纲
* 核心listData可以接收原始数组,也可以接收树形数组;需要这样设计,保证兼容性
* git问题:如果A文件夹使用了git init 在A文件夹下会有一个.git文件夹, A文件夹下面有 B项目文件夹和一个A.txt文本;
  B文件夹是一个微信小程序项目,然后在B文件夹下使用git init,B文件夹下生成了一个.git 文件夹. A文件夹使用了git log和B文件夹使用了git log发现展示的提交记录不一样,展示的都是A,B文件夹各自的;
  这种情况是不是意味着A,B文件夹属于两套不同的git 控制系统?
  /*
    是的，你描述的情况说明 A 文件夹和 B 文件夹分别是两个独立的 Git 仓库，它们之间没有直接的关联。虽然它们在文件系统上有一些共享的目录结构，但各自拥有独立的 Git 配置和版本历史。

	当你在 A 文件夹中运行 git init，Git 会在 A 文件夹下创建一个新的仓库，并生成 .git 目录以存储版本历史等信息。同样，当你在 B 文件夹中运行 git init，Git 会在 B 文件夹下创建一个独立的仓库，也会生成 .git 目录。

	因此，A 文件夹和 B 文件夹的提交历史是相互独立的，它们各自跟踪并记录文件的更改。如果你想将它们合并成一个仓库，你可以考虑在一个更高层次的目录（比如 A 文件夹的上级目录）中进行 git init，

	然后将 A 文件夹和 B 文件夹添加为该仓库的子目录。这样它们就可以在同一个仓库中共享版本历史。
  */
### 实现
1. 完善tree,inside(ok)
2. 把inside的点击节点展开先做了 => 先能够简单展示(ok)
	* 首先来个 isShowChildren 属性来控制节点展开收缩(ok)
	
3. 优化下样式: (ok )
	* scss的激活简便写法: =>  &.active也就是说& 和 .active是兄弟关系,而不是父子关系
		<div class="treeList active">
		  <!-- 其他内容 -->
		</div>
		
		=> 
		.treeList {
		 
		  &.active {
			background-color: aqua;
		  }
		}
		
	* 	
	
	
# 优化树的点击事件
## 大纲
* inside的bindtap绑定为 nodeClick(ok)
* 递归点击事件(ok)
* 现在有个问题需要优化:就是我的showChildren是否需要isShowChildren来控制?
	-> isShowChildren的优势是:适合做初始的全局控制,例如初始就展开所有节点,但是不会保留节点展开状态=>因为wx:if
	-> 如果想要保留节点状态,使用hidden => 可以做个状态标记控制 => keepAlive去控制(ok)
	
	
# 先发布一个gitHub版本 (OK)
## 大纲:
* 目前的基本功能:
	1. 可以展示最基本展示树了
	2. 可以得到点击的节点信息了
	3. 并且具备是否保留点击节点状态的选项
	

# 做一个点击印记功能:(OK)
## 大纲
* 点击印记需要排他思想
* 点击了某个节点,需要把当前的祖先全部找到
* 把点击的节点和rootTree拿到,然后做一个Tree遍历,然后设置一个新属性isClick

### 实现
1. 首先需要知道rootTree是不是引用传递 => 设置那个isClick:true属性没有发生引用传递(OK)
	1. nodeClick函数增加一个新属性,isClick试试 => 导出去的node节点有isClick:true的属性,但是在rootTree没有发生改变
	
2. 需要拿到当前节点和rootTree去取travel设置:
	* 需要有一个options来帮助,例如idStr这些标识符号
	* 我需要传一个treeOptions对象:
	    treeOptions: {
		  dotBg: '#666666',
		  recordTrack: true, //是否开启点击轨迹记录
		  searchBg: '#00DDAA' //搜索匹配的背景颜色
		}
		=> treeOptions去设置接口
		
	* 但是现在有个问题,印记需要用到每个对象的唯一标识符
	=> 如果单独传个对象标识符,那么整棵树是否被限制?
	
3. 现在我们这个listData需要拦截了
	* 现在可以直接把list给tree组件,但是observes监听到了listData就要去验证,需要配合treeOptions
	1. 现在我直接把movieList给WxTree=> 展示了,但是都是父亲
	2. 我需要写一个验证器 Verify(OK)
	3. treeOptions需要有 isTreeConstruct //是否已经是树结构 (OK)
	4. 准备一颗TreeOptions配置(OK)
	5. 如果不是树,肯定要读取相关标识符号,相关treeOptions需要写一份默认的,因为我默认是children和title:(OK)
		  interface TreeOptions {
			[key: string]: any;
			isTreeConstruct?: boolean,  //给定的数组是否已经就是属性结构,默认:false
			dotBg?: string  //原点的背景色,#ffffff等十六进制颜色,默认:#808080
			searchBg?: string //搜索状态下,如果搜索成功了,匹配的节点的背景色(#ffffff等十六进制颜色)
			recordTrack?: boolean //是否开启点击印记,true表示开启;默认:false
			treeObjProps: {
			  id:string
			  title: string,  //树形UI用于展示的文本
			  fatherId: string, //树的指针,如{name:'文本标题',parentId:2,child:[....]},fatherId在此时取'parentId'
			  children: string //树孩子的名称,例如上行例子,取'child'
			}
		  }
		  
	6. 在Verify.ts需要导入convertToTree(OK)
		* 就是这个id和title和children都要传入的参数来(OK)
		* 那么需要TS函数重载
	7. 那么子组件的渲染的数据就要treeList而不是listData(OK)
	8. 那么inside组件的命名是否要有讲究呢?=> 因为现在是遍历treeList,并且把treeList的每一个item传给子组件了,那么listData->treeItem(OK)
	9. 那么inside之前用的title和children,是不是依赖 treeOptions.treeObjProps.title 
	10. 如果传入的listData本身就是一颗树
		* 那么fatherId也不是必须的啊=> 传空就行(OK)
		* 原生树直接返回就好了(OK)
		@ 转化树的name是不是多余啊
		
4. 现在开始思考下点击印记如何设计:(OK)
	* 点击印记应该在树里面开启
	* 可以在顶层拿到当前点击的节点和rootTree,那么应该在rootTree里面进行一个排他思想:
	/*
	  traverseTree(tree, clickedNode, idStr) {
		for (const node of tree) {
 
		  if (node[idStr] == clickedNode[idStr]) {
			node.isClick = true
		  } else {
			node.isClick = false
		  }

		  if (node.children && node.children.length > 0) {
			this.traverseTree(node.children, clickedNode, idStr);
		  }
		}
	  }
	*/
	* 需要考虑下方法的时间复杂度和空间复杂度 => 对于小规模树可行,对于大规模树,效率极差
	
	* rootTree可以拷贝一份做副本=>setData({treeList}) => 可以来个treeListOrigin(对treeList的一份拷贝)
	* 还是travelTree,只不过我找到这棵树,node的isClick设为true,然后立马return travel
	* 当我第二次点击的时候,我是不是就拿treeListOrigin,这样我找到你,就直接return
	
	
# 做一个点击印记的颜色以及原点颜色可配置的功能
## 大纲
* 首先配置圆点颜色(OK)
* 点击的印记背景色的配置
	=> 暂时的实现方式可能是比较冗余::
		    <view class="text {{treeItem.isClick?'click-active':''}} " 
			style="background-color:{{treeItem.isClick?options.clickBg:''}}" bind:tap="nodeClick" mark:item='{{treeItem}}'>{{treeItem[title]}}</view>